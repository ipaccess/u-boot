/*
 * Copyright(c) 2007-2014 Intel Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program; if not, write to the Free Software 
 * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 * The full GNU General Public License is included in this distribution 
 * in the file called LICENSE.GPL.
 *
 * Contact Information:
 * Intel Corporation
 */

#include <config.h>
#include <common.h>
#include <asm/arch/hardware.h>
#include <asm/arch/dejitter.h>
#include <asm/arch/ad9548_19_2_mhz_tcxo.h>
#include <div64.h>

//
// Defines for code options:
//
#define PC73300_BOARD_SUPPORT

static void MillisecondWait(unsigned int ms)
{
    udelay(ms);
}


// Base defines for enabling/disabling chips
//#define TI_CDCE_62005 1
#if 1
/** @brief Define to allow setting/programming/usage of Analog Devices AD9548 PLL */
#define AD9548                  1
#endif

#if 0
/** @brief Define to allow setting/programming/usage of Analog Devices AD9553 PLL */
#define AD9553                  1
#endif

#define GHZ_SYSCLK

#if 0
/** @brief Dejitter debug defines (turns on printf, additional checking, etc.) */
#define DEBUG_DEJITTER
#endif

#ifndef SYSRC_SUCCESS
#define SYSRC_SUCCESS 0
#endif

#define CYPRESS_I2C_ADDRESS                 (0x69 << 1)

// Lower I2C register base, 0x08-0x17 (16 registers)
// Note: Cypress program generates registers 0x08-0x1B,
//       Datasheet describes ..... registers 0x08-0x17
// Only programming what is in the datasheet for now
// and not what is listed as reserved by the program
//
#define CYPRESS_I2C_LOWER_REGISTER_BASE     0x08
#define CYPRESS_I2C_LOWER_REGISTER_COUNT    16

// Upper I2C register base, 0x40-0x57 (24 registers)
#define CYPRESS_I2C_UPPER_REGISTER_BASE     0x40
#define CYPRESS_I2C_UPPER_REGISTER_COUNT    24

/* Generated by Alan K. Bartky 2013-03-22
 * Using Cypress CyClocksRT imported into
 * Excel template to generate C code
 */

/*
    _____   _____________________
   / __\ \ / / _ \ _ \ __/ __/ __|
  | (__ \ ^ /|  _/   / _|\__ \__ \
   \___| |_| |_| |_|_\___|___/___/ TIMING TECHNOLOGY
  ==================================================

                     ______________
                   _|*    \__/     |_  ________
             CLKC |_| 1         16 |_| SHUTDOWN/OE
                   _|              |_     _______
              VDD |_| 2         15 |_| S2/SUSPEND
                   _|              |_
             AGND |_| 3         14 |_| AVDD
                   _|              |_
           XTALIN |_| 4         13 |_| SCLK
                   _|   CY22393    |_
          XTALOUT |_| 5         12 |_| SDAT
                   _|              |_
             XBUF |_| 6         11 |_| GND
                   _|              |_
             CLKD |_| 7         10 |_| CLKA
                   _|              |_
             CLKE |_| 8          9 |_| CLKB
                    |______________|


Generated by CyClocksRT R3.10.00

Modification Date: 8/22/2010
Comments:
Customer:
FAE:
License #: bm0kd1gd1-ns6ps0cc2

*/

/**
 * @brief Clocking for testing on EVM with T2200
 * and T3300 EVMs with 10 MHz input from
 * AD9548 PLL into as reference clock into the CY22393 and
 * where output clock is synchronized to that.
 *
 * @details
 *
<tt><pre>

Generated by CyClocksRT R3.10.00

Modification Date: 2013-03-22
Comments: Clock for radio testing onT2200 and T3300 EVM, 10 MHz in from AD9548, 125 MHz to TSU on CLKA
Customer: Intel
FAE: Alan K. Bartky (Intel)
License #: bm0kd1gd1-ns6ps0cc2

Reference Input:   10.000000 MHz External
PLL 1:         Entry 0:     P: 75    Q: 2
               Entry 1:     P: 75    Q: 2
PLL 2:                      P: 0     Q: 0
PLL 3:                      P: 0     Q: 0

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  |    Off     |    Off     |   Off    |
| Pll2 |   -   |  Ref  |    Off     |    Off     |   Off    |
| Pll1 |   0   |  Ref  | 375.000000 | 375.000000 |   0.0    |
| Pll1 |   1   |  Ref  | 375.000000 | 375.000000 |   0.0    |
=============================================================

Clock Output
=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKE |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKD |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKC |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKB |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKA |   -   |  Pll1/3  | 125.000000 | 125.000000 |  +0.0    |  3.3V  |
=========================================================================

</pre></tt>
 */

const UINT8 CypressConfigDataLowerRegisters10MHzInput[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0000000(0) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x00<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0000000(0) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x00<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000000(0) */
    (0x00<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b00(0) */
    (0x00<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b00(0) */
    (0x00<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b00(0) */
    (0x01<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b01(1) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x00<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00000000(0) */
    (0x00<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000000(0) */
    (0x00<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x00<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b00(0) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegisters10MHzInput[] =
{
    (0x00<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x22<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00100010(34) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};


#ifdef PC73300_BOARD_SUPPORT
const UINT8 CypressConfigDataLowerRegisters25MHzInput[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000000(0) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x03<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0000011(3) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x00<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000000(0) */
    (0x00<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b00(0) */
    (0x01<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b01(1) */
    (0x01<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b01(1) */
    (0x00<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b00(0) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x00<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00000000(0) */
    (0x00<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000000(0) */
    (0x00<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x00<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b00(0) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegisters25MHzInput[] =
{
    (0x00<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x0C<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00001100(12) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x02<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b010(2) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x0C<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00001100(12) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x0C<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00001100(12) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x0C<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00001100(12) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};

#endif

const UINT8 CypressConfigDataLowerRegistersDisabled[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000000(0) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0000000(0) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x05<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0000101(5) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x00<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000000(0) */
    (0x00<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b00(0) */
    (0x00<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b00(0) */
    (0x00<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b00(0) */
    (0x00<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b00(0) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x00<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00000000(0) */
    (0x00<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000000(0) */
    (0x00<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x01<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b01(1) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegistersDisabled[] =
{
    (0x00<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};



extern unsigned I2CDrvWriteBytes(
    unsigned char DeviceAddress,
    unsigned char RegisterAddress,
    unsigned char* pData,
    unsigned short RequestedLength);

void CypressPLLInit(UINT32 InitOption)
{
    int BytesWritten;
    PUINT8 pLowerRegisterProgramData;
    PUINT8 pUpperRegisterProgramData;

        if (InitOption <= DEJITTER_INIT_IDLE)
        {
        printf("Disabling CY22393 ");
            pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegistersDisabled;
            pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegistersDisabled;
        }
    else if (InitOption == DEJITTER_INIT_PC73300)
    {
        printf("Enabling  CY22393 for PC73300 board ");
        pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegisters25MHzInput;
        pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegisters25MHzInput;
    }
        else
        {
        printf("Enabling  CY22393 ");
        pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegisters10MHzInput;
        pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegisters10MHzInput;
        }

        BytesWritten =  I2CDrvWriteBytes(CYPRESS_I2C_ADDRESS,               // (0x69 << 1)
                                         CYPRESS_I2C_LOWER_REGISTER_BASE,   // 0x08
                                         pLowerRegisterProgramData,         // data
                                         CYPRESS_I2C_LOWER_REGISTER_COUNT   // length
                                        );

        BytesWritten += I2CDrvWriteBytes(CYPRESS_I2C_ADDRESS,                // (0x69 << 1)
                                         CYPRESS_I2C_UPPER_REGISTER_BASE,    // 0x40
                                         pUpperRegisterProgramData,          // data
                                         CYPRESS_I2C_UPPER_REGISTER_COUNT    // length
                                        );

    if (BytesWritten != (CYPRESS_I2C_LOWER_REGISTER_COUNT+CYPRESS_I2C_UPPER_REGISTER_COUNT))
    {
        printf("CypressPLLInit: I2C write failure: Bytes Written:%u, Attempted:%u\n",
               BytesWritten,
               (CYPRESS_I2C_LOWER_REGISTER_COUNT+CYPRESS_I2C_UPPER_REGISTER_COUNT)
               );
    }
}

#define TI_DAC_8_BIT_ADDRESS (0x48<<1)
#define TI_DAC_SET_DAC_VALUE 0x10

void SetI2cDacValue(unsigned short DacValue)
{
    int BytesWritten;
    unsigned char buf[2];
    //
    // TI DAC8571 is set using I2C address value, then 0x10 to store
    // and activate the DAC value, then most significant 16 bits,
    // then least signifcant.  At the end of this I2C command
    // The TI DAC both stores and automatically activates the value
    // to change the output DAC voltage based on the value (from
    // 0x0000 to 0xFFFF
    //
    buf[1] = DacValue & 0xFF;
    buf[0] = DacValue >> 8;
    BytesWritten = I2CDrvWriteBytes(TI_DAC_8_BIT_ADDRESS,  // (0x48 << 1)
                                    TI_DAC_SET_DAC_VALUE,  // 0x10
                                    buf,                   // data
                                    2                      // length
                                   );

    if (BytesWritten != 2)
    {
        printf("SetI2cDacValue: I2C write failure: Data bytes written:%u, attempted:%u\n",
               BytesWritten,
               2
               );
    }
    else
    {
        printf("DAC8571: Set value 0x%04X OK\n",DacValue);
    }
}

#define AD9548_READ_CMD                 0x80
#define AD9548_WRITE_CMD                0x00
#define AD9548_XFER_ONE_BYTE_CMD        0x00
#define AD9548_XFER_TWO_BYTES_CMD       0x20
#define AD9548_XFER_THREE_BYTES_CMD     0x40
#define AD9548_XFER_STREAM_MODE_CMD     0x60

#ifdef AD9553
/** @brief AD9553 register base values for registers 0x0A-0x29 */
static const UINT8 AD9553RegisterBaseValues[] =
{
        /* PLL and PFD control 0x0A - 0x0D */

        0x56, /* Register 0x0A: PLL Charge Pump current (n x 3.5 uA) */
        0xB0, /* Register 0x0B: Charge pump and PFD control register */
        0x00, /* Register 0x0C: Charge Pump PFD clock dividers (used for test only via test mux */
        0x00, /* Register 0x0D: Antibacklash control [7:6} and PLL Lock detector power down [0] */

        /* Register 0x0E: VCO control */
        0xF4, /* Register 0x0E: VCO control, force VCO calibration which starts after I/O update  */
        0x80, /* Register 0x0F: VCO level control, controls VCO amplitude */
        0x80, /* Register 0x10: VCO band control,  controls VCO frequency band */
        0x00, /* Register 0x11: Unused */
        0x00, /* Register 0x12: Bits [19:12] of Feedback divider (N) */
        0x18, /* Register 0x13: Bits [11:4 ] of Feedback divider (N) */
        0x0C, /* Register 0x14: Bits [11:4 ] of Feedback divider (N) and misc. control bits */
        0x01, /* Register 0x15: Bits [ 9:2 ] of the 11 bit P1 divider */
        0x40, /* Register 0x16: Bits [ 1:0 ] of the 11 bit P1 divider & [9:4] of P2 divider */
        0x51, /* Register 0x17: Bits [ 3:0 ] of the 11 bit P2 divider and test port control */
        0x20, /* Register 0x18: Bits [ 2:0 ] of the 11 bit P0 divider */
        0x20, /* Register 0x19: Unused */
        0x00, /* Register 0x1A: Input receiver and Band gap control */

        /* XTAL control (registers 0x1B to 0x1E) */
        0x00, /* Register 0x1B: XTAL tuning capacitor control */
        0x00, /* Register 0x1C: Unused */
        0x00, /* Register 0x1D: Unused */
        0x00, /* Register 0x1E: Unused */

        /* REFA frequency control: 0x1F-0x21 */
        0x00, /* Register 0x1F: Bits [13:6] of the 14-bit REFA divider */
        0x12, /* Register 0x20: Bits [5:0] of the 14-bit REFA divider and SPI port divider control */
        0xA0, /* Register 0x21: REFA x2A and /5A select and SPI control */

        0x00, /* Register 0x22: Unused */

        /* REFB frequency control: 0x23-0x25 */
        0x00, /* Register 0x23: */
        0x12, /* Register 0x24: */
        0xA0, /* Register 0x25: */

        0x00, /* Register 0x26: Unused */

        /* DCXO frequency and referecne switchover control */
        0x07, /* Register 0x27: */
        0xD2, /* Register 0x28: */
        0x00, /* Register 0x29: */
};

/** @brief AD9553 register base values for registers 0x32-0x39 */
static const UINT8 AD9553RegisterUpperValues[] =
{

        0xA1, /* Register 0x32: OUT1 driver control 0xA1: strong drive strength, active, LVDS, register control mode */
        0x00, /* Register 0x33: Unused */
        0xA1, /* Register 0x34: OUT2 driver control 0xA1: strong drive strength, active, LVDS, register control mode */
        0x00, /* Register 0x35: */
        0x80, /* Register 0x36: */
        0x0C, /* Register 0x37: */
        0xDC, /* Register 0x38: */
        0xFF, /* Register 0x39: */
};
#endif // ifdef AD9553


// Bit reflect byte
unsigned char MsbLsbConvert8(unsigned char nVal)
{
    unsigned char nNew = 0x0;
    unsigned char i;

    for (i = 0; i <= 7; i++)
    {
        nNew = nNew << 1;
        nNew |= (nVal >>i )&0x01;
    }

    return nNew;
}

#ifdef DEBUG_DEJITTER
UINT32 DejitterDumpStart = 2;
UINT32 DejitterDumpEnd   = 3;
#endif

#ifdef DEBUG_DEJITTER
/** @brief Function to dump register values from the main dejitter PLL device */
static UINT32 DejitterDumpRegisters(char * InfoString, UINT32 busID, UINT32 cs, UINT32 start, UINT32 length)
{
    UINT32 i=start;
    UINT32 j=(i+length)-1;
    UINT32 readData;

    if (InfoString)
    {
        printf(InfoString);
    }
    for (; i<=j; i++)
    {
        readData = DejitterRead(i,busID,cs);
        printf("Dejitter Register 0x%04X read:0x%02X\n",
                   i,
                   readData
                   );
        MillisecondWait(20); // Delay to make sure all data displayed
    }
    return SYSRC_SUCCESS;
}
#endif

#ifdef DEBUG_DEJITTER
/**
 * @brief function to dump all registers from the dejitter devices
 */
static UINT32 DejitterDumpAllRegisters(char * InfoString, UINT32 busID, UINT32 cs)
{

    UINT32 i,j;
    UINT32 readData;

    if ((cs == AD9548_SPI_CS) && (busID == AD9548_SPI_BUS_ID))
        {
            // AD9548 0x0-0x0E3F (with gaps)
                // 0xD00-0xD19 status register
            i = 0xd00;
            j = 0xd19;

        }
#ifdef AD9553
    else if ((cs == AD9553_SPI_CS) && (busID == AD9553_SPI_BUS_ID))
        {
            // AD9553 0, 0x04-0x34
            i = 0;
            j = 0x34;
        }
#endif
    else
    {
        // Placeholer for other possible future supported PLL
        printf("Unknown/Invalid BUS_ID:GPIO %u:%u for Dejitter device\n",busID,cs);
        return SYSRC_INVALID_PARAM;
    }
    if (InfoString)
    {
        printf(InfoString);
    }
    for (; i<=j; i++)
    {
        readData = DejitterRead(i,busID,cs);
        printf("Dejitter Register 0x%04X read:0x%02X\n",
                   i,
                   readData
                   );
        MillisecondWait(20); // Delay to make sure all data displayed
    }
    return SYSRC_SUCCESS;
}
#endif

/**
 * @brief Function to compare values of the dejitter PLL versus a table of values
 *
 * @returns 0 if OK, else if mismatch, returns number of mismatches
 */
UINT32 DejitterCompareAllRegisters(PUINT8 pDataToCompare,
                                   UINT32 busID,
                                   UINT32 cs,
                                   UINT32 FirstRegister,
                                   UINT32 LastRegister
                                  )
{
    UINT32 i;
    UINT32 rc=0;
    UINT32 readData;
    UINT32 compareData;
    for (i=FirstRegister; i<=LastRegister; i++)
    {
        readData    = DejitterRead(i,busID,cs);
        compareData = *pDataToCompare++;
        if (readData != compareData)
        {
            printf("Dejitter Register %u read:0x%02X expected:0x%02X\n",
                   i,
                   readData,
                   compareData
                   );
            rc++;
        }
    }
    return rc;
}

UINT32 DejitterWriteAllRegisters(PUINT8 pDataToWrite,
                                 UINT32 length,
                                 UINT32 busID,
                                 UINT32 cs,
                                 UINT32 FirstRegister
                                 )
{
    UINT32 i,j;
    PUINT8 pCurrentWriteData = pDataToWrite;

    j = FirstRegister+length-1;
    for (i=FirstRegister; i<=j; i++)
{
        DejitterWrite(i,*pCurrentWriteData++, busID, cs);
    }
    return(DejitterCompareAllRegisters(pDataToWrite, busID, cs, i, j));
}

#ifdef DEBUG_DEJITTER
UINT32 SpiReadTest = 0;
#endif

void AD9548Write(UINT32 Reg, UINT32 Val)
{
    DejitterWrite(Reg,Val,AD9548_SPI_BUS_ID,AD9548_SPI_CS);
}

UINT32 AD9548Read(UINT32 Reg)
{
    return(    DejitterRead(Reg,AD9548_SPI_BUS_ID,AD9548_SPI_CS));
}

/** @brief Function to write a series of byte values to the AD9548 starting
 * at a Register Base offset
 *
 * @param [in] RegBase    Register offset to write bytes to AD9548
 * @param [in] pInitData     Pointer to series of bytes to write to the AD9548 starting at the Register base offset
 * @param [in] TableByteSize Number of bytes to write to the AD9548 starting at the Register base offset
 *
 * @returns Nothing (void return)
 */
void AD9548WriteBlock(UINT32 RegBase, PUINT8 pInitData, UINT32 TableByteSize)
{
    UINT32 Val;

    while(TableByteSize--)
    {
        Val = (UINT32)(*pInitData++);
        AD9548Write(RegBase++,Val);
    }
}

/** @brief Function to manually force free run loop to a selected frequency
 *
 * This is used for testing only where you want to adjust the free run PLL
 * when PLL is driving radio chip and you want to manually change the frequency offset
 * for testing purposes.
 *
 */
void DejitterSetFreeRunLoopHz(UINT32 LoopRateInHz)
{
	u64 Count64;
	int i;
	u8  ByteValue;
	u16 RegisterAddr;

	Count64 = (u64)LoopRateInHz;    // Get desired rate in Hz and convert to 64 bits
	//
	// First Left shift by 36, to max out 64 bit register value
	//
	Count64 = Count64 << 36ULL;
	//
	// Divide by 100000
	//
	do_div(Count64,100000);
	//
	// Left shift the rest for 48 bit field (6 bytes) calc
	//
	Count64 = Count64 << 12ULL;
	//
	// Final divide for actual system clock 9984 * 100000
	//
	do_div(Count64,9984);   // Divide by system clock internal frequency (19.2 MHz * 52);
	//
	// Write out count 8 bits at a time to registers 0x300 through 0x305
    // least significant byte first
	//
	printf("AD9548: Setting PLL main loop free run frequency to %u Hz\n",LoopRateInHz);
	for (i=0; i<=5; i++)
	{
		ByteValue     = (u8)(Count64 & 0xFFULL);
		RegisterAddr  = 0x300+i;
		//printf(" 0x%04X:%02X",RegisterAddr,ByteValue); // TEMP DEBUG
		AD9548Write(RegisterAddr,ByteValue);
		Count64 = Count64 >> 8ULL;
	}
	//printf("\n"); // TEMP DEBUG
	AD9548Write(5,1);
}

/** @brief Function to manually force select (instead of automatic mode) AD9548 input
 * timing clock source pin (0-7) as primary reference timing, if 8 or greater
 * all inputs are disabled.
 *
 * Normally, in this mode, if the primary reference is not present, the AD9548 is programmed
 * to change to Freerun mode and produce output timing based on the TCXO attached to it.
 */
void DejitterSelectSource(UINT32 ClockSourceId)
{
    AD9548Write(0xa00,0); // Write 0 to 0xA00 to put 9548 into normal mode

    if (ClockSourceId < 8)
    {
        // Select source A, AA, B, BB, etc.
        // TEMP DEBUG CODE, SETUP FOR TXCO TESTING
        AD9548Write(0xA01,
                       0
                    | (0<<6) // 0:   User holdover, nomral operation
                    | (0<<5) // 0: Freerun mode, not forced into free run (normal automatic mode)
                  //| (0<<3) // 00:  Automatic mode
                  //| (1<<3) // 01:  Fallback  mode
                  //| (2<<3) // 10:  Holdover mode
                    | (3<<3) // 11:  Manual mode (reference selected in bits 2:0
                    | (ClockSourceId<<0) // Select clock source 0-7
                   ); // Force the device into free-run mode

    }
    else
    {
        // Force AD9548 into freerun mode
        // TEMP DEBUG CODE, SETUP FOR TXCO TESTING
        AD9548Write(0xA01,
                    0
                    | (0<<6) // 0:   User holdover, nomral operation
                    | (1<<5) // 1:   Force device into free run mode
                  //| (0<<3) // 00:  Automatic mode
                  //| (1<<3) // 01:  Fallback  mode
                  //| (2<<3) // 10:  Holdover mode
                    | (3<<3) // 11:  Manual mode (reference selected in bits 2:0
                    | (0<<0) // Select clock source 0-7 (disabled, free run)
                   ); // Force the device into free-run mode
    }
    //
    // Generate the output clock
    // Set and clear the sync distribution bit to generate a clock
    // distribution sync pulse, which causes the synthesized output signal
    // to appear at the clock distribution outputs
    //
    // Calibrate the system clock, write bit 1 of 0xa02 register, then clear bit
    // each time with an I/O update
    AD9548Write(0xa02,(1<<1));

#if 1

    if (ClockSourceId < 8)
    {
        //
        // Start profile selection State machine based on desired inputs (1 for start, 0 for ignore)
        //
        AD9548Write(0xa0d, (1 << ClockSourceId) // Detect selected input reference
                   );
#if 0
        //
        // Select any signals that override the reference monitor fault signal (1 == override, 0 == not overrided)
        //
        AD9548Write(0xa0f, (1 << ClockSourceId)
                   );
#endif
#if 0

        //
        // Select any signals that bypass the reference monitor for the inputs (1 == bypass, 0 == monitor enabled)
        //
        AD9548Write(0xa10, (1 << ClockSourceId)
                   );
#endif
    }
    else
    {
        // No source selected, shut down state machine based on all inputs disabled
        AD9548Write(0xa0d, 0);
    }
#endif


    AD9548Write(5,1);
    AD9548Write(0xa02,0);
    AD9548Write(5,1);
}

/** @brief Function to manually setup AD9548 output
 * timing clock output pin (0 for OUT0P/N, 1 for OUT1P/N, 2 for OUT1P, etc.)
 * for desired mode of operation and speed.
 *
 */


void DejitterSetupOutput(UINT8 ClockOutId, UINT8 ClockOutMode, UINT32 ClockOutSpeed)
{
    UINT16 OutputModeRegister;
    UINT16 OutputDivisorRegister;
    UINT32 OutputDivider;
    int    i;

#ifdef DEBUG_DEJITTER
    printf("\n%s: ID:%u Mode:0x%02X Speed:%u\n",__func__,ClockOutId,ClockOutMode,ClockOutSpeed);
#endif
    // Calculate Register Values
    OutputModeRegister    = 0x404 +  ClockOutId;
    OutputDivisorRegister = 0x408 + (ClockOutId << 2);
    OutputDivider         = (DEJITTER_MAIN_LOOP_RATE_HZ / ClockOutSpeed) - 1;

    // Update divisor of port, one byte at a time, least significant first
    for (i=0; i<=3; i++, OutputDivider >>=8, OutputDivisorRegister++)
    {
        AD9548Write(OutputDivisorRegister, (OutputDivider & 0xFF));
        //printf("%s: Reg:0x%04X Val:0x%02X\n",__func__,OutputDivisorRegister, (OutputDivider & 0xFF));
    }

    // Update Mode of port
    AD9548Write(OutputModeRegister,ClockOutMode);
    //printf("%s: Reg:0x%04X Val:0x%02X\n",__func__,OutputModeRegister, ClockOutMode);

    // Commit register changes
    AD9548Write(5,0x01);

    // Issue Sync output to start/restart all ports
    // Set and clear bit 1
    AD9548Write(0xA02,0x02);
    AD9548Write(0xA02,0x00);

}

#ifdef AD9553
void AD9553Write(UINT32 Reg, UINT32 Val)
{
    DejitterWrite(Reg,Val,AD9553_SPI_BUS_ID,AD9553_SPI_CS);
}

UINT32 AD9553Read(UINT32 Reg)
{
    return(    DejitterRead(Reg,AD9553_SPI_BUS_ID,AD9553_SPI_CS));
}

void AD9553WriteBlock(UINT32 RegBase, PUINT8 pInitData, UINT32 TableByteSize)
{
    UINT32 Val;

    while(TableByteSize--)
    {
        Val = (UINT32)(*pInitData++);
        AD9553Write(RegBase++,Val);
    }
}
#endif

#ifdef DEBUG_DEJITTER
UINT32 PauseDejitterInit=0;
UINT32 DejitterResetTest=0;
#endif

/** @brief Function to initialize PLLs on EVM board to a functioning state.
 */
void   DejitterInit  (UINT32 InitOption, UINT32 ClockSource)
{
    SPICONFIG SpiConfig;
 // UINT32    writeData;
    UINT32    readData;
    int       i;

    //
    // Print dejitter start message (AD9548 takes multiple seconds, so basic
    // progress messages are printed as the chip is being initialized
    //
    printf("Dejitter/Clocking PLLs Init Option %u, Source: %u\n",InitOption,ClockSource+1);

    //
    // Initialize the Cypress PLL to correct input clocks, output clocks
    // divisors, etc. prior to setting up the TI or Analog devices dejitter device
    //
    // NOTE: All T2200/T3300 boards
    // have a Cypress PLL CY22393 as part of the dejitter/timing circuit
    // CypressPLLInit determines board type and based on that outputs
    // the correct data to program the part via I2C to the external Cypress PLL.
    //
    printf("CY22393: ");
    CypressPLLInit(InitOption);
    if (InitOption == DEJITTER_INIT_PC73300)
    {
        printf("OK\n");
        return;
    }
    printf("OK, ");

    if (InitOption <= DEJITTER_INIT_IDLE)
    {
         return; // don't initialize AD9548 or AD9553 unless Radio or CPRI selected
    }

    //
    // Initialize SPI operation
    //
    // Setup SPI options
    //
    memset(&SpiConfig,0,sizeof(SpiConfig));
    SpiConfig.frameSize    = SPI_FRAME_SIZE_8BITS;
    SpiConfig.frameFormat  = SPI_MOTOROLA_FORMAT;
    SpiConfig.clkMode      = SPI_CLOCK_MODE3;  /* SPI_CLOCK_MODE1; */
    SpiConfig.transferMode = SPI_RX_TX_ENABLE;
    SpiConfig.frqDivider   = SPI_DIVIDER_SPEED_KHZ(225); // Set to same speed as AD9548 Eval board
//  SpiConfig.frqDivider   = SPI_DIVIDER_SPEED_KHZ(100); // DEBUG TRYING SLOWER SPEED

    SpiConfig.BusID        = AD9548_SPI_BUS_ID;          // Bus ID of AD9548 and/or AD9553 (boards, bus 0)

    // Initialize SPI driver
    SPIDrvInit(&SpiConfig);

#ifdef AD9553
    printf("AD9548/9553: ");
#else
    printf("AD9548: ");
#endif

#ifdef DEBUG_DEJITTER
      do
      {
#endif
        //
        // For femtocell board, we only initialize the clock once at startup.
        // This is as for this board, clocking is the same setup for
        // Radio and CPRI mode as the board's clocking is setup to
        // always provide the proper clock for both operations
        //
        // So if not startup init, just return
        //
#if 0
        if (InitOption != DEJITTER_INIT_STARTUP)
        {
            printf("OK\n");
            return;
        }
#endif
        // Write to register 0 to setup default values for operation + reset to put
        // AD9548 and AD9553 chips into a known state
#if 1
        printf("Reset, ");
#ifdef DEBUG_DEJITTER

#endif
        AD9548Write(0,
                      0
                      | (1<<7)  // 1 4wire mode, 0 (default) 3wire mode
                      | (0<<6)  // 1 Least significant bit & Byte first, 0 (default) MSB and msb
                      | (1<<5)  // 1 Reset, 0 (default) normal opearation
                      | (1<<4)  // Read only, always one
                      // Inverse data (to allow for register 0 in lsb or msb mode
                      //| (1<<3) | (1<<2) | (0<<1) | (1<<0)
                     );
#ifdef AD9553
        AD9553Write(0,
                      0
                      | (0<<7)  // Bit 7: Reserved, always 0
                      | (0<<6)  // Bit 6: 1 Least significant bit & Byte first, 0 (default) MSB and msb
                      | (1<<5)  // Bit 5: 1 Reset, 0 (default) normal opearation
                      | (1<<4)  // Bit 4: Read only, always 1
                      // Inverse data (to allow for register 0 in lsb or msb mode
                      //| (1<<3) | (1<<2) | (0<<1) | (0<<0)
                     );
#endif

        MillisecondWait(100);

#if 0
        //
        // TEMP FOR TCXO DEBUG, ALWAYS SETUP CLOCK AT STARTUP
        // SO IT CAN BE MEASURED
        //
        if (InitOption <= DEJITTER_INIT_IDLE)
        {
            // If IDLE or STARTUP, chips are reset and should be shutdown
            // make sure by killing output
            AD9548Write(0x401,0x00); // Set AD9548 OUT0 - OUT3 to disabled
#ifdef AD9553
            AD9553Write(0x032,0xE1); // Set AD9553 OUT1 to powered down
            AD9553Write(0x034,0xE1); // Set AD9553 OUT2 to powered down
#endif
            printf("Disabled/n");
            return;
        }
#endif

#endif // #if 1 on chip reset

#ifdef DEBUG_DEJITTER
        printf("Release from reset AD9548\n");
#endif
        // Write to register 0 to setup default values for operation
        AD9548Write(0,
                      0
                      | (1<<7)  // 1 4wire mode, 0 (default) 3wire mode
                      | (0<<6)  // 1 Least significant bit & Byte first, 0 (default) MSB and msb
                      | (0<<5)  // 1 Reset, 0 (default) normal opearation
                      | (1<<4)  // Read only, always 1
                      // Inverse data (to allow for register 0 in lsb or msb mode
                      //| (1<<3) | (0<<2) | (0<<1) | (1<<0)
                     );
#if 0
        //
        // TEMP TEMP TEMP FOR DEBUG, AD9548 NOT YET WORKING
        // FOR SOME REASON ON ALL MSPD T2200/T3300 BOARDS
        // JUST RETURN FOR NOW
        return;
        //
        // Temp debug loop, write register 0 with normal
        // value and check read back, loop until OK
        //
        printf("TEMP AD9548 DEBUG LOOP\n");
        i = 1;
        MillisecondWait(10);
        while (i)
        {
            readData = AD9548Read(0);
            if ((readData == 0x90) || (readData == 0x99))
                break;
            MillisecondWait(3);
            AD9548Write(0, 0x90); // Write already has 3 millisecond delay
        }
#endif


#ifdef AD9553
#if 0
        //
        // AKB TEMP PATCH FOR TESTING AD9553
        // AD9553 AND AD9548 ARE BOTH HOOKED UP TO GPIO 12 FOR RESET
        // BUT UNFORTUNATELY, AD9548 USES RESET AND AD9553 USES OPPOSITE POLARITY
        // RESET_N.
        // TEMP FOR TEST, SETUP GPIO 12 AS OUTPUT AND SET TO HIGH POLARITY
        // TO TAKE THE AD9553 OUT OF RESET (NOTE THIS WILL PUT THE AD9548 INTO RESET
        //
        printf("Releasing AD9553 from physical reset\n");
        REG32(GPIO_OE_REG)         |= GPIO_12;
        REG32(GPIO_OUTPUT_REG)     &= ~(GPIO_12);
        REG32(GPIO_PIN_SELECT_REG) |= GPIO_12;
        MillisecondWait(1000);
#endif
        // Write to register 0 to setup default values for operation
        AD9553Write(0,
                      0
                      | (0<<7)  // Bit 7: Reserved, always 0
                      | (0<<6)  // Bit 6: 1 Least significant bit & Byte first, 0 (default) MSB and msb
                      | (0<<5)  // Bit 5: 1 Reset, 0 (default) normal opearation
                      | (1<<4)  // Bit 4: Read only, always 1
                      // Inverse data (to allow for register 0 in lsb or msb mode
                      //| (1<<3) | (0<<2) | (0<<1) | (0<<0)
                     );
#endif  // #ifdef AD9553

        MillisecondWait(100);
#ifdef DEBUG_DEJITTER

        do
        {
            DejitterDumpAllRegisters("AD9548 Status Registers after reset:\n",
                                     AD9548_SPI_BUS_ID,
                                     AD9548_SPI_CS
                                    );    // AKB TEMP DEBUG
#ifdef AD9553
            DejitterDumpAllRegisters("AD9553 Status Registers after reset:\n",
                                     AD9553_SPI_BUS_ID,
                                     AD9553_SPI_CS
                                    );    // AKB TEMP DEBUG
#endif // ifdef AD9553
        }
        while (SpiReadTest);
#endif // ifdef DEBUG_DEJITTER

#ifdef AD9553
        //
        // Program AD9553
        //
        // Program base registers from 0x0A to 0x29
        //
        AD9553WriteBlock(0x0A,(PUINT8)&AD9553RegisterBaseValues, sizeof(AD9553RegisterBaseValues));
        //
        // Program upper registers from 0x32 to 0x39
        //
        AD9553WriteBlock(0x32,(PUINT8)&AD9553RegisterUpperValues, sizeof(AD9553RegisterUpperValues));
        //
        // Issue I/O update
        //
        AD9553Write(5,1);

#ifdef DEBUG_DEJITTER
        DejitterDumpRegisters("AD9553 register read back:\n",
                              AD9553_SPI_BUS_ID,
                              AD9553_SPI_CS,
                              0x0,
                              0x39
                             );
        DejitterDumpRegisters("AD9553 status read back:\n",
                              AD9553_SPI_BUS_ID,
                              AD9553_SPI_CS,
                              0xFE,
                              0x2
                             );
#endif // #ifdef DEBUG_DEJITTER
#endif // #ifdef AD9553


        printf("Programming, ");
        // Follow initialization steps as outlined in AD9548 datasheet

        // Program 0x100 register bank
        AD9548WriteBlock(0x100,
                         (PUINT8)&AD9548Register100BankValues,
                         sizeof(AD9548Register100BankValues)
                        );

        // Initialize the system clock by writing to register 5, Bit 0 (self clearing)
        // Send an I/O update
        AD9548Write(5,1);
        MillisecondWait(10);

#ifdef DEBUG_DEJITTER
        DejitterDumpRegisters("0x100 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0x100,
                              sizeof(AD9548Register100BankValues)
                             );
        DejitterDumpRegisters("0xD00 Status read:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0xD00,
                              0x19
                             );
        while(PauseDejitterInit==1);

#endif

#if 0
        // TEMP DEBUG CODE TO RESET CHIP, BUT PRESERVE REGISTER SETTINGS
        AD9548Write(0xa00,0x80);
        AD9548Write(5,1);
        MillisecondWait(500);
        AD9548Write(0xa00,0x00);
        AD9548Write(5,1);
        MillisecondWait(1000);
#endif



#if 1
        // Calibrate the system clock, write bit 0 of 0xa02 register, then clear bit
        // each time with an I/O update
        AD9548Write(0xa02,1);
        AD9548Write(5,1);
        MillisecondWait(500); // Set to 1/2 second, same as that used in the AD9548 evaluation software
        AD9548Write(0xa02,0);
        AD9548Write(5,1);
        MillisecondWait(10);
#endif

#ifdef DEBUG_DEJITTER

        DejitterDumpRegisters("0xD00 bank read back after calibration:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0xD00,
                              0x20
                             );

        while (PauseDejitterInit==2);
#endif

        //
        // AD9548 Watchdog, interrupts, etc. are not used, so register 0x200 bank is skipped
        //

        //
        // Program the Digital Phase-Locked Loop (DPLL)
        // Output register space for 0x300 bank of registers
        //
        AD9548WriteBlock(0x300,
                         (PUINT8)&AD9548Register300BankValues,
                         sizeof(AD9548Register300BankValues)
                        );

        //
        // Register bank 0x400
        // Program the clock distribution outputs
        // based on functional mode for Radio, CPRI or startup/idle
        //
//      if (InitOption != DEJITTER_INIT_RADIO)
	if (1)
        {
            // CPRI (or other future clock option) clock selected, power up and enable all 4 output clocks from the AD9548
            AD9548Write(0x400, 0x00);
            AD9548Write(0x401, 0x0F);
        }
        else
        {
            //
            // Radio clock, only output 40 MHz clock to radio (OUT0) and 10 MHz clock to SMA conntector
            // This currently disables clock to devices such as the T4K TSU function, but this
            // creates less noise on the current MSPD T4K EVM that can be picked up by the radio
            // and cause some interference.
            //
            AD9548Write(0x400, 0x06);
            AD9548Write(0x401, 0x09);
        }
        //
        // Output the rest of the registers for the 0x400 bank of AD9548 registers
        //
        AD9548WriteBlock(0x402,
                         ((PUINT8)&AD9548Register400BankValues)+2,
                         sizeof(AD9548Register400BankValues)-2
                        );

        //
        // To match EEPROM startup sequence isse an I/O update after registers
        // 0x300 and 0x400 register block programming is complete
        //
        AD9548Write(5,1);
        MillisecondWait(10);

#ifdef DEBUG_DEJITTER
        MillisecondWait(5000);
        DejitterDumpRegisters("0xD00 bank read back after 0x400 bank written:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0xD00,
                              0x20
                             );

        while (PauseDejitterInit==3);
#endif

        //
        // Register bank 0x500
        // Program the clock distribution outputs
        //
        AD9548WriteBlock(0x500,
                         (PUINT8)&AD9548Register500BankValues,
                         sizeof(AD9548Register500BankValues)
                        );

        //
        // Register banks 0x600, 0x680, 0x700 and 0x780
        // Program the reference profiles 0-7 (2 profiles per register bank)
        //
        AD9548WriteBlock(0x600,
                         (PUINT8)&AD9548Register600BankValues,
                         sizeof(AD9548Register600BankValues)
                        );

        // Program profiles 2-7 if present
//#if defined(AD9548Register680BankValues)
        AD9548WriteBlock(0x680,
                         (PUINT8)&AD9548Register680BankValues,
                         sizeof(AD9548Register680BankValues)
                        );
//#endif
//#if defined(AD9548Register700BankValues)
        AD9548WriteBlock(0x700,
                         (PUINT8)&AD9548Register700BankValues,
                         sizeof(AD9548Register700BankValues)
                        );
//#endif
//#if defined(AD9548Register780BankValues)
        AD9548WriteBlock(0x780,
                         (PUINT8)&AD9548Register780BankValues,
                         sizeof(AD9548Register780BankValues)
                        );
//#endif

        //
        // Issue an I/O update to invoke all of the register settings
        // programmed up to this point
        //
        AD9548Write(5,1);
        MillisecondWait(10);

#ifdef DEBUG_DEJITTER
        MillisecondWait(5000);
        DejitterDumpRegisters("0xD00 bank read back after 0x700 bank written:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0xD00,
                              0x20
                             );

        while (PauseDejitterInit==4);
#endif

        // Generate the reference aquisition (PLACEHOLDER FOR FUTURE CODE,
        // FOR NOW, JUST GO WITH A FIXED REFERENCE OR FREE RUN


        // Register bank 0xa00, just need selected registers
        MillisecondWait(1000);

        // Start off by selecting Free run clock (this may be changed
        // later).
        DejitterSelectSource(ClockSource);


#ifdef DEBUG_DEJITTER
        MillisecondWait(1000);
        DejitterDumpAllRegisters("AD9548 status Registers after 0xA00 registers written:\n",
                                 AD9548_SPI_BUS_ID,
                                 AD9548_SPI_CS
                                );    // AKB TEMP DEBUG
#endif



#ifdef DEBUG_DEJITTER
        MillisecondWait(1000);
        DejitterDumpRegisters("0x300 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0x300,
                              sizeof(AD9548Register300BankValues)
                             );
        DejitterDumpRegisters("0x400 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0x400,
                              sizeof(AD9548Register400BankValues)
                             );
        DejitterDumpRegisters("0x500 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0x500,
                              sizeof(AD9548Register500BankValues)
                             );
        DejitterDumpRegisters("0x600 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0x600,
                              sizeof(AD9548Register600BankValues)
                             );
        DejitterDumpRegisters("0x700 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0x700,
                              sizeof(AD9548Register700BankValues)
                             );
        DejitterDumpRegisters("0xA00 bank read back:\n",
                              AD9548_SPI_BUS_ID,
                              AD9548_SPI_CS,
                              0xA00,
                              0x11
                             );
        MillisecondWait(1000);
        DejitterDumpAllRegisters("AD9548 Status Registers after init & delay:\n",
                                 AD9548_SPI_BUS_ID,
                                 AD9548_SPI_CS
                                );    // AKB TEMP DEBUG
#endif

        // Make sure after all this programming AD9548 SYSCLK PLL is OK
         readData = AD9548Read(0xD01);
         printf("SYSCLK: ");
         if (readData == 0x11)
         {
             // SYSCLK is OK, wait one
             printf("OK, DPLL: ");
             // Give time to PLL to allow for lock to input clocks
             i = 500;
             do
             {
                 // Read DPLL status, should be 0x32 (phase locked, frequency locked and running)
                 readData = AD9548Read(0xD0A);
                   if ((readData == 0x32) || (readData == 0x72) || (readData == 0x41))
                 {
                       printf("OK: 0x%02X\n",readData);
                     break;
                 }
                   else
                   {
                       MillisecondWait(2);
                   }
             } while (i--);
             if (i<=0)
             {
                 printf("FAILED VALUE: 0x%02X\n",readData);
             }
         }
         else
         {
             printf("FAILED VALUE: 0x%02X\n",readData);
         }
#ifdef DEBUG_DEJITTER
         MillisecondWait(5000);
      } while (DejitterResetTest);
#endif

}

/**
 * @brief Function to read a single value from register address passed
 *
 * @details
 *
 * For AD9548 and AD9553, this reads a single byte but returns it as
 * 32 bits
 *
 */

UINT32 DejitterRead(UINT32 addr, UINT32 busID, UINT32 cs)
{
    UINT8               rx_data[4];
    UINT8               tx_data[4];
        UINT32 data;
    S_SPI_TRANSFER_DES  SpiTransferDescriptor;

#ifdef AD9548_LSB_MODE
        //
        // LSB mode, Address is sent first, but byte reversed
        //
    tx_data[0] = MsbLsbConvert8((UINT8) (addr     &0xFF));           //address bits A0:A7
    tx_data[1] = MsbLsbConvert8((UINT8) ((  ((addr>>8) & 0x1f)       //address bits A8:A12
                                              |  AD9548_READ_CMD              //read operation
                                              |  AD9548_XFER_ONE_BYTE_CMD     //one byte read
                                             )
                                             & 0xFF
                                            )
                                   );
#else
        //
        // MSB mode, Most significant Address and command is sent first,
        // then remaining address bits
        //
    tx_data[0] = (UINT8) ( ((addr>>8) & 0x1f)           //address bits A8:A12
                                |  AD9548_READ_CMD            //read operation
                                |  AD9548_XFER_ONE_BYTE_CMD   //one byte read
                             ) & 0xFF
                             ;
    tx_data[1] = (UINT8) (addr &0xFF);            //address bits A0:A7
#endif
    //
    // Setup SPI transfer descriptor
    //
    SpiTransferDescriptor.command_ptr = tx_data;  /* Command data (first n bytes sent of SPI message) */
    SpiTransferDescriptor.tx_data_ptr = NULL;     /* Pointer to data to transmit (if any) after command cycle completed, NULL if nothing to TX */
    SpiTransferDescriptor.rx_data_ptr = rx_data;  /* Pointer to data to receive  (if any) after command cycle completed, NULL if nothing to RX */
    SpiTransferDescriptor.cmd_size    = 2;        /* Number of bytes for this command (includes any address bytes) */
    SpiTransferDescriptor.data_size   = 1;        /* Amount of data to send and/or receive after command cycle */

    SPIDrvTransfer(busID, cs, &SpiTransferDescriptor);

    data = rx_data[0] & 0xFF;

    return data;
}

void DejitterWrite(UINT32 addr, UINT32 data, UINT32 busID, UINT32 cs)
{
    UINT8               tx_data[4];
    S_SPI_TRANSFER_DES  SpiTransferDescriptor;

    //
    // Setup transmit data
    //
    tx_data[0] = (UINT8) (addr >> 8);
    tx_data[1] = (UINT8)  addr;
    tx_data[2] = (UINT8)  data;
    //
    // Setup SPI transfer descriptor
    //
    SpiTransferDescriptor.command_ptr = tx_data;  /* Command data (first n bytes sent of SPI message) */
    SpiTransferDescriptor.tx_data_ptr = NULL;     /* Pointer to data to transmit (if any) after command cycle completed, NULL if nothing to TX */
    SpiTransferDescriptor.rx_data_ptr = NULL;     /* Pointer to data to receive  (if any) after command cycle completed, NULL if nothing to RX */
    SpiTransferDescriptor.cmd_size    = 3;        /* Number of bytes for this command (includes any address bytes) */
    SpiTransferDescriptor.data_size   = 0;        /* Amount of data to send and/or receive after command cycle */

    SPIDrvTransfer(busID, cs, &SpiTransferDescriptor);

            //printf("Write gpio 0x%08X: Read back : 0x%02X, 0x%02X, 0x%02X\n",gpio,byte1,byte2,data);
            MillisecondWait(3);  //AD9548 eval board firmware has a delay between transactions
    }

// eof dejitter.c
