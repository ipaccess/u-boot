/*
 * Copyright(c) 2007-2014 Intel Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program; if not, write to the Free Software 
 * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 * The full GNU General Public License is included in this distribution 
 * in the file called LICENSE.GPL.
 *
 * Contact Information:
 * Intel Corporation
 */

#include <common.h>
#include <asm/arch/hardware.h>

extern int get_t2200_rev(void);

#define T2200_REV_X1        1
#define T2200_REV_X2        2
#define T2200_REV_X2_1      3

void SysDelayUs(u32 us)
{
    volatile u32 StartTick;
    volatile u32 ticks;

    StartTick = REG32(TIMER0_CURR_COUNT);
    ticks = (AXICLK_HZ/1000000)*us;
    while ((REG32(TIMER0_CURR_COUNT) - StartTick) < ticks);
}

void SysDdrPhyInit(void)
{
    volatile unsigned val;

    REG32(TIMER0_CNTR_REG) = (u32)0xFFFFFFFF;

    REG32(DDR3_RESET) = 0;
    SysDelayUs(100);

    REG32(0xF4CA0004) |= (1<<7); //PIR[DRAMRST]:
    REG32(0xF4CA0004) |= (1<<0); //PIR[INIT]:
#ifdef RTL_SIM
    REG32(0xF4CA0028) = 0x180000e0;
    REG32(0xF4CA002c) = 0x05ac0070;
#endif
    do
    {
        val = REG32(0xF4CA0010);
    } while ((val & 1) != 1);


    //Program tPLLLOCK value based on 250MHz config clock:
    REG32(0xF4CA001C) = 0x3201F410;
    REG32(0xF4CA0020) = 0x3EE00800;

    REG32(0xF4CA000C) |= (1<<26);  //Setting PGCR1(26) to 1 to set VT calculation inhibit



    REG32(0xF4CA000C) |= (1<<7); //Put pads in DDR3 mode.

    REG32(0xF4CA02C0) &= ~1;    //disable byte 4 ecc byte
    REG32(0xF4CA0040) |= (1<<18);  //Setting Rise-to-rise mode register dsgcr bit 18
    REG32(0xF4CA0040) |= (1<<6);  //Setting enabling extended gate. DSGCR bit 6 to 1.

    REG32(0xF4CA000C) |= (1<<2);  //Setting PGCR1(2) to 1 to make wlstep to 1. Bug fix for star 9000502976
    REG32(0xF4CA0040) |= (1<<6);  //Setting enabling extended gate. DSGCR bit 6 to 1.


// MR2
    REG32(0xF4CA005c) = 0x000000d8; //km changed from 18 to 98 to extended temperature
// MR1
//    REG32(0xF4CA0058) = 0x00000006; // 34ohm
    REG32(0xF4CA0058) = 0x00000004; // 40ohm
// MR0
    REG32(0xF4CA0054) = 0x00000c70;  //500 Mhz mr0,mr1,mr2 = c40,06,08 or 18; 600 Mhz = c50, 06,10; 700 Mhz = d70 or c70, 6, 18
// Initialize SDRAM
    REG32(0xF4CA0004) |= (1<<8); //PIR[DRAMINIT]:
    REG32(0xF4CA0004) |= (1<<0); //PIR[INIT]:

    REG32(0xF4CA0048) = 0x919c8866;
    REG32(0xF4CA004c) = 0x1a861480; //DTPR1. Chance to c2. bits 19:11. original value is 58.
    REG32(0xF4CA0050) = 0x3002d200;

// Enable ODT data termination
    REG32(0xF4CA003C) |= (1<<0); //enable odt data termination.

    //7->4 ODT 4 = 240/4=120 ohm
    //3->0 output impedance 6 = 240/6=40 ohm
    //REG32(0xF4CA0194) = 0x000000bd; //setting it to 34 ohm output driver resistance. register zq1cr1. odt(bits 7 to 4) set to 40 ohm.
    REG32(0xF4CA0184) = 0x00000046; //zq0cr1: set output driver resistance (bits[3:0]) = 40 ohm. set odt(bits 7 to 4) = 120 ohm.
    REG32(0xF4CA0194) = 0x00000046; //zq0cr1: set output driver resistance (bits[3:0]) = 40 ohm. set odt(bits 7 to 4) = 120 ohm.
    REG32(0xF4CA01A4) = 0x00000046; //zq0cr1: set output driver resistance (bits[3:0]) = 40 ohm. set odt(bits 7 to 4) = 120 ohm.
    REG32(0xF4CA01B4) = 0x00000046; //zq0cr1: set output driver resistance (bits[3:0]) = 40 ohm. set odt(bits 7 to 4) = 120 ohm.

    SysDelayUs(1000);
#ifdef DDR_2_RANKS
    REG32(0xF4CA0068) = 0x030015c7; // for 2 ranks
#else
    REG32(0xF4CA0068) = 0x010015c7; // for 1 rank
#endif

    // Setting PHY parameters:
    REG32(0xF4CA003C) = 0x00001ee5; //0x00007ee5;
    // changing DQS and DQS_N resistor value to 340 ohm to reduce noise
    REG32(0xF4CA003C) |= (1<<7); //
    REG32(0xF4CA003C) |= (1<<6); //dqs resister set to 340 ohm
    REG32(0xF4CA003C) |= (1<<5); //
    // Adding this slew rate - recovers the failing boards
    REG32(0xF4CA0038) |= (1<<31); //increase slew rate
    REG32(0xF4CA0038) |= (1<<30); //

    // ZQ calibration
    REG32(0xF4CA0004) |= (1<<1); //ZCAL: impedance calibration
    REG32(0xF4CA0004) |= (1<<0); //Start SDRAM init


        SysDelayUs(500);

    // Start Training
    REG32(0xF4CA0004) = 0x0000ff81; 

    val = REG32(0xF4CA0028);
    val = REG32(0xF4CA002c);
#ifdef RTL_SIM
    val = REG32(0xF4CA0010);
#else
    do
    {
        SysDelayUs(100);
        val = REG32(0xF4CA0010);
    } while ((val & 1) != 1);
#endif

//Moving LCDLR2 DQS gating delay  by 0x50 calibration units to compensate for mission mode fluctuation compared to PHY training
    REG32(0xF4CA01E8) += 0x30;  // dx2lcdlr2 //0->7 write data delay ,  15->8 read dqs delay, 23->16 read dqsn delay. original value
    REG32(0xF4CA0228) += 0x30;  // dx2lcdlr2 //0->7 write data delay ,  15->8 read dqs delay, 23->16 read dqsn delay. original value
    REG32(0xF4CA0268) += 0x30;  // dx2lcdlr2 //0->7 write data delay ,  15->8 read dqs delay, 23->16 read dqsn delay. original value
    REG32(0xF4CA02A8) += 0x30;  // dx2lcdlr2 //0->7 write data delay ,  15->8 read dqs delay, 23->16 read dqsn delay. original value
//
    SysDelayUs(10000);
}

void ddr3_init( void )
{
const unsigned char DdrControllerParams[0x297] = {
/*         0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e 0x1f */
/* 0x000 */0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0xa0,0x00,0x00,0x00,0x90,0x01,0x00,0x00,0x00,0x16,0x08,0x04,0x04,0x05,0x26,0x1c,0x06,0x0a,0x06,0x0c,0x0c,0x60, //changing cas latency is changed t0 11. cwl to 8.
/* 0x020 */0xdb,0x00,0x04,0x04,0x00,0x00,0x01,0x01,0x0a,0x0c,0x16,0x00,0x02,0x00,0x03,0x18,0x00,0x00,0x0b,0x00,0x00,0x01,0x01,0x01,0x92,0x00,0x3c,0x0c,0x00,0x05,0x00,0x14, // for 500 MHz //tref refresh is important. should be more than x82
/* 0x040 */0x00,0x02,0x00,0x06,0x00,0x00,0x02,0x60,0x00,0x00,0x00,0x01,0x00,0x00,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* 0x060 */0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x0c,0x06,0x00,0xd8,0x00,0x00,0x00,0x00,0x00,0x60,0x0c,0x06,0x00,0xd8,0x00,0x00,0x00,0x00,0x00,0x60,0x0c,0x06, //changing mr0 and mr2 to match 400 Mhz setting.
/* 0x080 */0x00,0xd8,0x00,0x00,0x00,0x00,0x00,0x60,0x0c,0x06,0x00,0xd8,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //ECC is removed
/* 0x0a0 */0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01,0x40,0x00,0x00,0x02,
/* 0x0c0 */0x40,0x00,0x01,0x01,0x00,0x01,0x0a,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x03,0x03,0x00,0x00,0x01,0x0c,0x00, 0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00, //change cs_map for enabling only 1 rank// reduc is d7. it does 16 bit transaction instead of 32.
/* 0x0e0 */0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x02, //odt_rd_map & odt_wr_map for one chip select.
/* 0x100 */0x02,0x04,0x01,0x08,0x02,0x00,0x02,0x02,0x01,0x02,0x00,0x01,0x00,0x02,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,
/* 0x120 */0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* 0x140 */0x00,0x23,0x23,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x23,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x23,0x01,0x00,0x00,
/* 0x160 */0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x23,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x23,0x01,0x00,0x33,0x33,0x00,0x00,0x00,0xff,0xff,
/* 0x180 */0x02,0x02,0x00,0xff,0xff,0x02,0x02,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xff,0xff,0x0f,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x00, //change port_addr_protection_en to 0.
/* 0x1a0 */0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,
/* 0x1c0 */0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,
/* 0x1e0 */0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,
/* 0x200 */0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,
/* 0x220 */0xff,0x0f,0x03,0x03,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x0f,0x03,0x03,0xff,0xff,0x03,0x32,0x01,0xff,0x32,0x01,0x03,0x32,0xff,0xff,0x64,0x00,0x00,0x00,0x00,0x00,
/* 0x240 */0x00,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x62,0x18,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x62,0x18,0xea,0x79,0x00,0x00,0x06,0x04,0x02,0x00,0x01,0x00,0x80,0x03,
/* 0x260 */0x03,0x07,0x04,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x10,0x00,0x03,0x03,0x07,0x1b,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* 0x280 */0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x01
};
    volatile unsigned char *p_ddr_params = (unsigned char *)DdrControllerParams;
    volatile unsigned value;
    volatile unsigned *p_mem;
    unsigned i;
    int dev_id;

    //DDR M1 Port programming
    REG32(L2CC_FILTER_END) = 0x80000000;
    REG32(A9IC_SCU_FILTER_END) = 0x80000000 - 1;
    REG32(L2CC_FILTER_START) = 1; // enable L2CC filtering
    REG32(A9IC_SCU_FILTER_START) = 0;

    SysDdrPhyInit();

    dev_id = get_t2200_rev();

    if (dev_id == T2200_REV_X2_1) {
        volatile unsigned char *p_ddr_regs = (volatile unsigned char *)DDR0_CONTROLLER_BASE;

        for (i = 0; i < sizeof(DdrControllerParams); i++)
            *p_ddr_regs++ = p_ddr_params[i];

        *(volatile unsigned char *)DDR0_CONTROLLER_BASE = 0x01;

        // poll INT_STATUS register (222) for value bit 1 set to 1

        do
            value = *(volatile unsigned char *)(DDR0_CONTROLLER_BASE + 222);
        while ((value & 2) == 0);
    } else {
        volatile unsigned int *p_ddr_regs = (unsigned int *)DDR0_CONTROLLER_BASE;
        for (i = 0; i < sizeof(DdrControllerParams); i++) {
            *(volatile unsigned char *)p_ddr_regs = p_ddr_params[i];
            p_ddr_regs++;
        }

        *(volatile unsigned char *)DDR0_CONTROLLER_BASE = 0x01;

        // poll INT_STATUS register (222) for value bit 1 set to 1

        do
            value = *(volatile unsigned char *)(DDR0_CONTROLLER_BASE + 4*222);
        while ((value & 2) == 0);
    }



    p_mem = (unsigned *)0;
    *p_mem = 0; // dummy write
}

